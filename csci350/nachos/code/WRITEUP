Title:  Writeup for Project 3, Fall 2015
Date:  11/09/15
Group 16:     Name                        Email
              Rochelle (Shelly) Willard   rwillard@usc.edu
              Ananth Mohan                   ananthmo@usc.edu
              Matthew Burke                  matthelb@usc.edu

I. Requirements:
Part 1: Use a cache for virtual address translation by enabling and populating the translation lookaside buffer (TLB) for nachos.

Part 2: Implement virtual memory by creating an inverted page table and using a swap file.

Part 3: Implement implement remote procedure calls for the lock, condition variables, and monitor variable system calls.

II. Assumptions:
Part 1:
The size of the TLB remains fixed at 4 entries. Additionally, the TLB uses a FIFO policy for replacement/eviction of pages (cycling through the entries sequentially). Finally, on every process switch (not necessarily a thread context switch), all the entries in the TLB are invalidated.

Part 2:
If the amount of pages requested for a user program exceeds the amount of pages available in the swap file, the program will fail to run. The number of pages available in the swap file is 10,000 (defined in userprog/swap.h)

Part 3: 
Server machine ID is always 0 and user programs are only single threaded processes.

III. Design:

Part 1:
- Use the already existing TLB to populate entries.
- On a PageFaultException, find or obtain a physical page for the requested virtual address, and set the physical page number, virtual page number, and dirty bits of the next-to-replace entry in the TLB, thereby overwriting it.
- On every context switch to a thread with a different address space, invalidate all the entries in the TLB so that pages are not incorrectly accessed when they are for a different process.
- Dirty bits are propagated to the IPT and page table for the process whenever a valid entry is evicted from the TLB.

Part 2:
Inverted page table
- Implemented as an array of InvertableTranslationEntry. The index in the array represents the physical page and the value represents a virtual page/address space pairing.
- Used to keep track of which physical memory pages are mapped to which virtual pages for a particular process. This information is used to determine whether or not a new page needs to be obtained or if an old page needs to be evicted.
- Populated when a free physical page is allocated to a virtual page for a process or when a physical page is evicted and swapped (or loaded from executable) with a virtual page for a process
Swap file
- Allows physical memory pages to be stored on the disk when they are not currently needed by the OS. 
- Populated when a physical page needs to be evicted from main memory to make room for another page. 
- Freed when a process exits and virtual pages for the process are stored in swap file.
- Eviction of physical pages to swap file can happen in FIFO order or by randomly choosing a page to swap. This is specified with the -P arguments on the command line (values are FIFO or RAND; no value or an invalid value will default to FIFO).

Part 3:
Server
- Implement a server to receive messages from the client using the post office class send/receive to communicate to the clients.
- Designed to perform one request at a time.  Reads the first part of message to figure operation to be performed and performs that operation.
- Stores locks, condition variables, and monitor variables as separate maps indexed by their id.
- Stores counts for next index to be used.
Client
- Implement locks, condition variables, and monitor variables as clients that communicate with the server.
- Verifies arguments passed, sends request to server and waits for response.

IV. Implementation:
+ Files Modified
userprog/exception.cc
userprog/addrspace.cc
userprog/addrspace.h
machine/machine.h
network/nettest.cc
test/start.s
threads/system.cc
threads/system.h
userprog/syscall.h
+ Files added
network/network_utility.h
test/matmult_virtual_mem_test.c
test/sort_virtual_mem_test.c
userprog/inverted_translation_entry.h
userprog/swappable_translation_entry.h
userprog/swap.cc
userprog/swap.h

+ Data Structures added, and the file they were added to.
class InvertableTranslationEntry : public TranslationEntry {-- in file userprog/invertable_translation_entry.h
  public:
    AddrSpace* owner;
};

enum DiskLocation { -- in file userprog/swappable_translation_entry.h
  NEITHER = 0,
  EXECUTABLE,
  SWAP,
  NUM_DISK_LOCATIONS
};

class SwappableTranslationEntry : public TranslationEntry {-- in file userprog/swappable_translation_entry.h
  public:
    int byteOffset;
    DiskLocation diskLocation;
};

// network/netttest.cc
struct Message {
    PacketHeader packetHdr;
    MailHeader mailHdr;
    char * data;
};

struct ServerLock {
    bool busy;
    int machineID;
    std::string name;
    bool toBeDeleted;
    std::deque<Message> waitQ;
};

struct ServerCV {
    int lockID;
    std::string name;
    bool toBeDeleted;
    std::deque<Message> waitQ;
};

struct ServerMV {
    std::vector<int> value;
    std::string name;
};

+ Data Structures modified, and the file they were added to.

+ Functions added and in which file.
userprog/exception.cc
// Looks for the location of the virtual address in physical memory and places it in the TLB
//   by searching the IPT. Calls HandleIPTMiss if cannot locate virtual page in IPT
void HandlePageFault(int vaddr);

// Assigns the specified virtual page to a physical page. If the physical page is already in use
//   the physical page is evicted from memory
int HandleIPTMiss(int vpn);

// Evicts a page from physical memory and returns the index of the evicted page
int HandleMemoryFull();

userprog/swap.h, userprog/swap.cc
// Writes the specified physical page to a page in the swap file and returns the index of
//   the swap page
int Swap::Write(int ppn);

// Writes the specified physical page to the specified byte offset in the swap file
void Swap::Update(int ppn, int offset);

// Reads a page from the specified byte offset in the swap file to the specified
//   physical page in memory
void Swap::Read(int ppn, int offset);

// Frees the specified byte offset in the swap file for use by another process
void Swap::Free(int offset);

userprog/addrspace.h, userprog/addrspace.cc
// Loads the specified virtual page for the current process into the specified physical page
//   Updates the IPT and PT with the new information
void AddrSpace::LoadPage(int vpn, int ppn);

// Removes the specified physical page from memory. Saves page to swap file if page is dirty.
//   MUST be called by the AddrSpace which currently owns the specified physical page
//   Updates the IPT and PT with the new information
//   Invalidates the physical page in the TLB if the physical page is in the TLB
void AddrSpace::EvictPage(int ppn);

userprog/exception.cc
// Syscall to create a monitor variable with the given name of length len and array size arr_size.
int CreateMonitor(char* name, int len, int arr_size);

// Syscall to set the monitor variable mv to value at the given index.
int SetMonitor(int mv, int index, int value);

// Syscall to get the monitor variable mv’s value at the given index.
int GetMonitor(int mv, int index);

// Syscall to destroy the monitor variable with the given id mv.
int DestroyMonitor(int mv);

network/nettest.cc
// Runs the server code needed for the remote procedure calls.
void Server() ;

+ Functions modified and in which file.
userprog/exception.cc
// Added case for PageFaultException, CreateMonitor, SetMonitor, GetMonitor, and DestroyMonitor to switch statement
void ExceptionHandler(ExceptionType which);

// Changed to be remote procedure call.
int CreateLock(char* name, int len);

// Changed to be remote procedure call.
int DestroyLock(int lock);

// Changed to be remote procedure call.
int CreateCondition(char* name, int len);

// Changed to be remote procedure call.
int DestroyCondition(int cv);

// Changed to be remote procedure call.
int Acquire(int lock);

// Changed to be remote procedure call.
int Release(int lock);

// Changed to be remote procedure call.
int Wait(int cv, int lock);

// Changed to be remote procedure call.
int Signal(int cv, int lock);

// Changed to be remote procedure call.
int Broadcast(int cv, int lo

userprog/addrspace.h, userprog/addrspace.cc
// Modified constructor to allow pages to be allocated on demand instead of at initialization
//   Also keeps a handle to the executable file until termination
AddrSpace::AddrSpace(char *executableFile);

// Modified destructor to close handle to executable file on termination
AddrSpace::~AddrSpace();

// Modified allocation of stack pages to allow pages to be allocated on demand
void AddrSpace::AllocateStackPages();

// Modified deallocation of pages to only free page if it is currently allocated for the process
void AddrSpace::DeallocateAllPages();

// Modified deallocation of pages to only free page if it is currently allocated for the process
void AddrSpace::DeallocateStack();

V. Testing:  (For each test case, you must show)
+ How to test Part 1/2
- cd vm
- gmake
- cd ../test
- gmake
- ../vm/nachos -x matmult_virtual_mem_test
- ../vm/nachos -x sort_virtual_mem_test
+ Test Output
- matmult_virtual_mem_test: Expected output is the value of the static matrix multiplication for 2 separate processes. This should look like “72207220”.
- sort_virtual_mem_test: Expected output is the value of the static sort for 2 separate processes. This should look like “10231023”.  *Note this test can take ~3 minutes to run*

+ How to test Part 3: Lock and Condition
- cd userprog
- gmake depend
- gmake
- cd ../test
- gmake
- cd ../network
- gmake depend
- gmake
- nachos -server -m 0 
- nachos -m 1 -x ../test/conditiontest1
- nachos -m 2 -x ../test/conditiontest2
+ Test Output
- Either use separate terminal windows or place ‘&’ at the end of a command to run the process in the background.
- Condition tests 1 & 2 test operations of lock and condition to make sure that resources are shared across user programs.  Condition test 1 calls wait on a cv.  Condition test 2 signals on that same cv. (Must be run in the order stated above.  Condition test 1 will not complete until condition test 2 is run.  You can run with the “-d R” to see additional debug output as desired.  Both programs should run to completion.

+ How to test Part 3: Monitor Variables
- cd network
- gmake
- nachos -server -m 0  
- nachos -m 1 -x ../test/monitortest
+ Test Output
- Monitor test tests all operations of monitor variable.  Creates a monitor variable of size 2, sets the values and retrieves them, and then destroys the monitor variable.

VI. Discussion:
+ Experiment expectation: Multiple user programs run to completion.  Locks, CVs, and MVs can be shared across processes.
+ Experiment result: Multiple user programs run to completion.  Locks, CVs, and MVs can be shared across processes.
+ Explanation: It works.  Check program output as validation.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.

